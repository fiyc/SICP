## 2.3 符号数据
> 到目前为止, 我们已经使用过所有复合数据, 最终都是从数据出发构造起来的. 在这一节里, 我们要扩充所用语言的表述能力, 引进将任意符号作为数据的功能.

### 2.3.1 引号
如果我们能够构造出采用符号的复合数据, 我们就可以有下面这类的表  
`(a b c d)`
`(23 45 17)`
`((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))`  

为了能够操作这些符号, 我们的语言里就需要有一种新元素: 为数据对象加 *引号* 的能力.如下面的例子:  
```lisp
(define a 1)

(define b 2)

(list a b)
(1 2)

(list 'a 'b)
(a b)

(list 'a b)
(a 2)

```
引号也可以用于复合对象, 其中采用的是表的方便的输出表示是方式:  

```lisp
(car '(a b c))
a

(cdr '(a b c))
(b c)
```

为了能对符号做各种操作, 我们还需要用另一个基本过程**eq?**，这个过程以两个符号作为参数, 检查他们是否为同样的符号.  
下面的例子利用eq?实现一个过程, 以一个符号和一个表作为参数, 返回这个符号是否在表中  

```lisp
(define (memq item x)
	(cond ((null? x) false)
	      ((eq? item (car x)) x)
		  (else (memq item (cdr x)))))
		  
(memq 'apple '(pear banana prune))
false

(memq 'apple '(x (apple sauce) y apple pear))
(apple pear)
```
代码 [SICP/code/demos/memq.scm](#)

#### 练习2.53
代码 [SICP/code/exercises/0074_2_53.scm](#)

#### 练习2.54
代码 [SICP/code/exercises/0075_2_54.scm](#)

#### 练习2.55
根据注释100上面说的, `(quote a)可以替代’a, 引号只不过是一种将下一完整表达式用(quote <expression>)形式包裹起来的单字符缩写形式`, 因此`（car ''abracadabra）`等同于`（car ‘（quote abracadabra））`

### 2.3.2 实例: 符号求导
为了阐释符号操作的情况, 并进一步阐释数据抽象的思想, 现在考虑设计一个执行代数表达式的符号求导的过程.

#### 对抽象数据的求导程序
首先让我们假定现在已经有了一些过程, 他们实现了下述的构造函数、选择函数和谓词  
```lisp
(variable? e) ;e是变量吗
(same-variable? v1 v2) ;v1和v2是同一个变量吗
(sum? e) ;e是和式吗
(added e) ;e的被加数
(augend e) ;e的加数
(make-sum a1 a2) ;构造器a1 和a2 的和式
(product? e) ;e是乘式吗
(multiplier e) ;e的被乘数
(multiplicand e) ;e的乘数
(make-product m1 m2） ;构造器m1 与m2的乘式
(number? e) ;是否数值
```

以下是各种求导规则的过程
```lisp
(define (deriv exp var)
	(cond ((number? exp) 0)
		  ((variable? exp)
			  (if (same-variable? exp var) 1 0))
		  ((sum? exp)
			  (make-sum (deriv (addend exp) var)
			            (deriv (augend exp) var)))
		  ((product? exp)
			  (make-sum (make-product (multiplier exp)
			                          (deriv (multiplicand exp) var))
			            (make-product (deriv (multiplier exp) var)
						              (multiplicand exp))))
		  (else (error "unknown expression type -- DERIV" exp))))
```
#### 代数表达式的表示
实现上面提到的构造函数、选择函数和谓词  

* 变量就是符号, 可以用基本谓词*symbol?*  
`(define (variable? x) (symbol? x))`  

* 两个变量相同就是他们的符号相互*eq?*  
```lisp
(define (same-variable? v1 v2)
	(and (variable? v1) (variable? v2) (eq? v1 v2)))
```  

* 和式与乘式都构造为表  
`(define (make-sum a1 a2) (list '+ a1 a2))`  
`(define (make-product m1 m2) (list '* m1 m2))`  

* 和式就是第一个元素为符号+的表  
```lisp
(define (sum? x)
	(and (pair? x) (eq? (car x) '+)))
```  

* 被加数是表示和式的表里的第二个元素  
`(define (addend s) (cadr s))`  

* 加数是表示和式的表里的第三个元素  
`(define (augend s) (caddr s))`  

* 乘式就是第一个元素为符号*的表  
```lisp
(define (product? x)
	(and (pair? x) (eq? (car x) '*)))
```  

* 被乘数是表示乘式的表里的第二个元素  
`(define (multiplier p) (cadr p))`  

* 乘数是表示乘式的表里的第三个元素  
`(define (multiplicand p) (caddr p))`  

以上代码 [SICP/code/demos/deriv.scm](#)  

修改生成和式与生成乘式的过程, 将结果化简到最简单的形式  

```lisp 
(define (=number? exp num)
	(and (number? exp) (= exp num)))

(define (make-sum a1 a2)
	(cond ((=number? a1 0) a2)
	      ((=number? a2 0) a1)
		  ((and (number? a1) (number? a2)) (+ a1 a2))
		  (else (list '+ a1 a2))))
		  
(define (make-product m1 m2)
	(cond ((or (=number? m1 0) (=number? m2 0)) 0)
	      ((=number? m1 1) m2)
		  ((=number? m2 1) m1)
		  ((and (number? m1) (number? m2)) (* m1 m2))
		  (else (list '* m1 m2))))
```








#### 练习2.56
代码 [SICP/code/exercises/0076_2_56.scm](#)

#### 练习2.57
代码 [SICP/code/exercises/0077_2_57.scm](#)

#### 练习2.58

### 2.3.3 实例: 集合的表示
一个集合就是一些不同对象的汇集. 要给出一个更精确的定义, 我们可以利用数据抽象的方法, 也就是说, 用一组可以作用于"集合"的操作来定义他们.如下:  

* union-set 计算出两个集合的并集
* intersection-set 计算出两个集合的交集
* element-of-set? 确定某个给定元素是不是某个给定集合的成员  
* adjoin-set 将一个对象加入到集合中, 返回新的集合

#### 集合作为未排序的表
集合的一种表示方式是用一个任何元素都出现不超过一次的表来表示.  
对于这种表示方式, **element-of-set?**类似于2.3.1节的过程 **memq**, 但它应该用equal? 而不是eq?, 以保证集合元素可以不是符号  
```lisp
(define (element-of-set? x set)
	(cond ((null? set) false)
		  ((equal? x (car set)) true)
		  (else (element-of-set x (cdr set)))))
```

利用上面的过程, 我们可以很简单的实现**adjoin-set**过程, 如果要加入的对象已经在相应集合里, 返回当前集合, 否则将用cons过程操作对象与集合  
```lisp
(define (adjoin-set x set)
	(if (element-of-set? x set)
		set
		(cons x set))
```
#### 集合作为排序的表

#### 练习2.61

#### 练习2.62

#### 集合作为二叉树

#### 练习2.63

#### 练习2.64

#### 练习2.65

#### 集合与信息检索

#### 练习2.66

### 2.3.4 实例: Huffman编码树

#### 生成Huffman树

#### Huffman树的表示

#### 解码过程

#### 带权重元素的集合

#### 练习2.67

#### 练习2.68

#### 练习2.69

#### 练习2.70

#### 练习2.71

#### 练习2.72

