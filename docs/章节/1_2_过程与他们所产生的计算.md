## 1.2 过程与他们所产生的计算
> 在程序设计里, 我们需要对计算过程中各种动作的进行情况作出规划, 用一个程序去控制这一过程的进展. 要想成为专家, 我们就需要学会去看清各种不同种类的过程会产生什么样的计算过程.  

### 1.2.1 线性的递归和迭代  
**递归计算过程** 一个*推迟进行的操作*所形成的链条, 收缩阶段表现为这些运算的实际执行的计算过程.  

**线性递归过程** 推迟执行的链条的长度随着n值而线性增长(正比于n)的*递归计算过程*.  

**迭代计算过程** 状态可以用固定数目的状态变量描述的计算过程, 而与此同时, 又存在着一套固定的规则, 描述了计算过程在从一个状态到下一个状态转换时, 这些变量的更新方式, 还有一个结束检测, 它描述这一计算过程应该终止的条件.  

**线性迭代过程** 所需的计算步骤随着n线性增长的迭代计算过程  

```lisp
;阶乘的两种计算过程的实现
;递归计算过程
(define (factorial n)
	(if (= n 1)
		1
		(* n (factorial (- n 1)))))

;迭代计算过程
(define (factorial n)
	(fact-iter 1 1 n))

(define (fact-iter product counter max-count)
	(if (> counter max-count)
		product
		(fact-iter (* counter product)
				   (+ counter 1)
				   max-count)))
```

#### 练习1.10  
将过程A代换入给定过程中转换即可  
[/SICP/code/exercises/0009_1_10.scm](#)

### 1.2.2 树形递归  
以菲波那切数列作为例子描述树形递归

```lisp
;递归计算过程
(define (fib n)
	(if (< n 2)
		n
		(+ (fib (- n 1))
		   (fib (- n 2)))))

;迭代计算过程
(define (fib n)
	(fib-iter 1 0 n))

(define (fib-iter a b count)
	(if (= count 0)
		b
		(fib-iter (+ a b) a (- count 1))))
```

### 实例: 换零钱方式的统计  
该实例是为了说明树形递归计算过程在解决某些特定问题的时候的作用  
**问题描述:** 给定半美元, 四分之一美元, 10美分, 5美分和1美分的硬币, 将1美元换成零钱, 一共有多少种不同方式  

解决这个问题的核心思路, 将问题分解如下:  

将总数为a的现金换成n种硬币的不同方式的数目等于  
* 将现金数a换成除第一种硬币之外的所有其他硬币的不同方式数目, 加上
* 将现金数a-d换成所有种类的硬币的不同方式数目, 其中d是第一种硬币的币值  

**代码示例** [/SICP/code/demos/count-change.scm](#)  

### 1.2.3 增长的阶  
描述不同的计算过程在消耗计算资源的速率上的差异  

**具体描述**  
R(n)是一个计算过程在处理规模为n的问题时所需的资源量, 如果存在与n无关的整数k1和k2, 使得  
	k1f(n) <= R(n) <= k2f(n)  

则称R(n)具有O(f(n))的增长阶, 记为R(n)=O(f(n))


















