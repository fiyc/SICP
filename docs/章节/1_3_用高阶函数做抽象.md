## 1.3 用高阶函数做抽象  
> 以过程作为参数或是返回值得过程, 被称为高阶过程. 本节将展示高阶过程如何能称为强有力的抽象机制, 极大的增强语言的表述能力.  

### 1.3.1 过程作为参数  
下面使用3个不同的求和过程, 将他们转为一个高阶过程  

1. 计算从a到b的各整数之和:  
```lisp
(define (sum-integers a b)
	(if (> a b)
		0
		(+ a (sum-integers (+ a 1) b))))
```  

2. 计算给定范围内的整数的立方之和:  
```lisp
(define (sum-cubes a b)
	(if (> a b)
		0
		(+ (cube a) (sum-cubes (+ a 1) b))))
```

3. 计算下面序列之和:  
1/(1*3) + 1/(5*7) + 1/(9*11) + ...  
```lisp
(define (pi-sum a b)
	(if (> a b)
		0
		(+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
```  

总结出上述三种求和过程的基础模式, 产生下面的模板  
```lisp
(define (<name> a b)
	(if (> a b)
		0
		(+ (<term> a)
		   (<name> (<next> a) b))))
```  

根据上面的模板, 产生了下面这样一个高阶过程:  
[/SICP/code/demos/sum.scm](#)  
```lisp
(define (sum term a next b)
	(if (> a b)
		0
		(+ (term a)
		   (sum term (next a) next b))))
```  

#### 练习 1.29
代码: [/SICP/code/exercises/0017_1_29.scm](#) 

#### 练习1.30 
代码: [/SICP/code/exercises/0018_1_30.scm](#) 

#### 练习1.31
代码: [/SICP/code/exercises/0019_1_31.scm](#) 

#### 练习1.32
代码: [/SICP/code/exercises/0020_1_32.scm](#) 

#### 练习1.33
代码: [/SICP/code/exercises/0021_1_33.scm](#) 


### 1.3.2 用lambda构造过程  
**lambda**定义语法:  
`(lambda (<formal-parameters>) <body>)`  

**用let创建局部变量**  
```lisp
(let ((<var1> <exp1>)
	  (<var2> <exp2>)
	  .
	  .
	  .
	  (<varn> <expn>))
	<body>)
```

### 1.3.3 过程作为一般性的方法  
#### 通过区间折半寻找方程的根
求方程 *f(x)=0* 的一种方法就是**区间折半法**. 这个方法的基本思想:  

对于函数f(x), 如果给订单a和b有 f(a) < 0 < f(b), 那么f在a和b之间必然有一个零点. 通过求f((a + b)/2) 的值来缩小区间.  

令 c = (a + b)/2
**如果 f(c) > 0**, 则问题转变为 f(a) < 0 < f(c)  
**如果 f(c) < 0**, 则问题转变为 f(c) < 0 < f(b)  
**如果 f(c) = 0**, 则c为f(x)的根  
同时, 当a与b之间的区间足够小时, 就结束这一过程, 实现过程如下  

```lisp
(define (search f neg-point pos-point)
	(let ((midpoint (average neg-point pos-point)))
		(if (close-enouth? neg-point pos-point)
			midpoint
			(let ((test-value (f midpoint)))
			     (cond ((positive? test-value)
			     		(search f neg-point midpoint))
			           ((negative? test-value)
			           	(search f midpoint pos-point))
			           (else midpoint))))))

(define (close-enough? x y)
	(< (abs (- x y)) 0.001))



;;加入f(a) f(b) 符号相同情况下的报错
(define (half-interval-method f a b)
	(let ((a-value (f a))
		  (b-value (f b)))
		(cond ((and (negative? a-value) (positive? b-value))
				(search f a b))
		      ((and (negative? b-value) (positive? a-value))
		      	(search f b a))
		      (else
		      	(error "Values are not of opposite sign" a b)))))
```

**找出函数的不动点**  





