## 2.2 层次性数据和闭包性质
> 我们可以建立元素本身也是序对的序对, 这就是表结构得以作为一种表示工具的根本基础. 我们将这种能力成为cons的闭包性质. 一般说, 某种组合数据对象的操作满足闭包性质, 那就是说, 通过它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合.  

### 2.2.1 序列的表示  
序列是利用序对构造出的一种结构, 可以理解为一个序对, 他的第一位是一个数据对象, 第二位是一个序对, 这个序对同样第一位是一个数据对象, 第二位是一个序对, 依次可以实现一批数据对象的一种有序汇集.  

直接使用cons来表示一个序列  
```lisp
(cons 1
	(cons 2
		(cons 3
			(cons 4 nil))))
```  
为了方便构造, Scheme提供了一个基本操作**list**.  

```lisp
(list <a1> <a2> <a3> ... <an>)
```
	
#### 表操作
利用序对将元素的序列表示为表之后, 我们就可以使用常规的程序设计技术, 通过顺序"向下cdr"表的方式完成对表的各种操作了.  

* 获取表的第n个项
```lisp
(define (list-ref items n)
	(if (= n 0)
		(car items)
		(list-ref (cdr items) (- n1))))
		
(define squares (list 1 4 9 25))

(list-ref squares 3)
16
```

* 使用null?判断参数是不是空表
```lisp
(define (length items)
		(if (null? items)
			0
			(+ 1 (length (cdr items)))))
			
(define odds (list 1 3 5 7))

(length odds)
4
```

* 两个表组合成新表
```lisp
(define (append list1 list2)
	(if (null? list1)
		list2
		(cons (car list1) (append (cdr list1) list2))))
```

以上三个过程代码 [/SICP/code/demos/list-actions.scm](#)
#### 练习2.17
代码[/SICP/code/exercises/0045_2_17.scm](#)

#### 练习2.18
代码[/SICP/code/exercises/0046_2_18.scm](#)

#### 练习2.19
代码[/SICP/code/exercises/0047_2_19.scm](#)

#### 练习2.20
代码[/SICP/code/exercises/0048_2_20.scm](#)

#### 对表的映射
一种特别有用的操作是将某种变换应用于一个表的所有元素, 得到所有结果构成的表.  
下面的例子是将一个表里所有元素按给定因子做一次缩放:
```lisp
(define (scale-list items factor)
	(if (null? items)
		nil
		(cons (* (car items) factor)
			  (scale-list (cdr items) factor))))
			  
(scale-list (list 1 2 3 4 5) 10)
(10 20 30 40 50)
```

抽象出这一具有一般性的想法, 得到一个高阶过程*map*
```lisp
(define (map proc items)
	(if (null? items)
		nil
		(cons (proc (car items))
	          (map proc (cdr items)))))
			  
(map abs (list -10 2.5 -11.6 17))
(10 2.5 11.6 17)

(map (lambda (x) (* x x))
	 (list 1 2 3 4))
(1 4 9 16)
```

#### 练习2.21
代码[/SICP/code/exercises/0049_2_21.scm](#)

#### 练习2.22
代码[/SICP/code/exercises/0050_2_22.scm](#)

#### 练习2.23
代码[/SICP/code/exercises/0051_2_23.scm](#)	

### 2.2.2 层次性结构
将表作为序列的标识方式, 可以很自然的推广到标识那些元素本身也是序列的序列.  
例如`（（1 2） 3 4）`下面的方式构造出来:  
`(cons (list 1 2) list 3 4())`  
我们可以把这种结构看作树, 序列里的元素就是树的分支, 而那些本身也是序列的元素就形成了树中的子树.下面的过程可以获取树中树叶的数目:  
```lisp
(define (count-leaves x)
	(cond ((null? x) 0)
		  ((not (pair? x)) 1)
		  (else (+ (count-leaves (car x))
		           (count-leaves (cdr x))))))
```
代码[/SICP/code/demos/count-leaves.scm](#)  

#### 练习2.24
代码[/SICP/code/exercises/0052_2_24.scm](#)

#### 练习2.25
代码[/SICP/code/exercises/0053_2_25.scm](#)

#### 练习2.26
代码[/SICP/code/exercises/0054_2_26.scm](#)

#### 练习2.27
代码[/SICP/code/exercises/0055_2_27.scm](#)

#### 练习2.28
代码[/SICP/code/exercises/0056_2_28.scm](#)

#### 练习2.29
代码[/SICP/code/exercises/0057_2_29.scm](#)

#### 对树的映射
要了解树的映射, 我们先做一个与之前**scale-list**类似的**scale-tree**过程, 保持树的形状, 给树中的每个数值乘以因子
```lisp
(define (scale-tree tree factor)
	(cond ((null? tree) nil)
		  ((not (pair? tree)) (* tree factor))
		  (else (cons (scale-tree (car tree) factor)
		              (scale-tree (cdr tree) factor)))))
					  
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
(10 (20 (30 40) 50) (60 70))
```
#### 练习2.30

#### 练习2.31

#### 练习2.32

### 2.2.3 序列作为一种约定的界面

#### 序列操作

#### 练习2.33

#### 练习2.34

#### 练习2.35

#### 练习2.36

#### 练习2.37

#### 练习2.38

#### 练习2.39

#### 嵌套映射

#### 练习2.40

#### 练习2.41

#### 练习2.42

#### 练习2.43

### 2.2.4 实例: 一个图形语言

#### 图形语言

#### 练习2.44

#### 高阶操作

#### 练习2.45

#### 框架

#### 练习2.46

#### 练习2.47

#### 画家

#### 练习2.48

#### 练习2.49

#### 画家的变换和组合

#### 练习2.50

#### 练习2.51

#### 强健设计的语言层次

#### 练习2.52
